#version 450

const int rows = 900;
const int cols = 900;

const int numCells = rows * cols;
const int dataLength = 3840; // ceil(900 * 4 / 256) * 256;

struct TexAttribData
{
	uvec4 c;
};
/*
layout(std140, set = 0, binding = 0) uniform SimParams {
    float deltaT;
    float rule1Distance;
    float rule2Distance;
    float rule3Distance;
    float rule1Scale;
    float rule2Scale;
    float rule3Scale;
} params;

layout(std140, set = 0, binding = 1) buffer CellsA {
    uint cells[numCells];
} cellsA;

layout(std140, set = 0, binding = 2) buffer CellsB {
    uint cells[numCells];
} cellsB;

layout(std140, set = 0, binding = 3) buffer destBuffer {
    TexAttribData data[numCells];
} colorDestBuffer;
*/
// layout(rgba32f, binding = 4) uniform image2D img_output;


layout(std140, set = 0, binding = 0) buffer destBuffer {
    TexAttribData data[numCells];
} colorDestBuffer;

const int states = 200;

void main() {
    // uint index = gl_GlobalInvocationID.x; 
    // if (index >= numCells) { return; }

    ivec2 coords = ivec2(gl_GlobalInvocationID.xy); 
    uint index = uint(coords.y * cols + coords.x);
    if (index >= numCells) { return; }

    // colorDestBuffer.data[index].c = uvec4(255.0 * float(coords.x) / float(900),1,1, 1);



    // tex.data[4 * index + 1] = 255;

    // int y = int(floor(float(index) / 900.0));
    // int x = int(index) - y * 900;
    // ivec2 coords = ivec2(x, y);

    // int state = cellsA.cells[index];

    // cellsB.cells[index] = (state + 1) % 200;

    // float c = float(states) / float(state);

    // tex.data[index] = 255;
    // tex.data[4 * index + 1] = 255;

    // c = float(numCells) / float(index);
    // tex.data[index] = uvec4(c, 0, 0, 1.0); 
    // tex.data[index] = uvec4(c, 0, 0, 255); 
    // tex.data[index] = uvec4(255, 255, 255, 255); 

    // tex.data[4 * index + 2] = 255; 
    // tex.data[index].y = 255; 
    // tex.data[index].z = 255; 

    // base pixel colour for image
    // vec4 pixel = vec4(0.0, 1.0, 0.0, 1.0);
    // get index in global work group i.e x,y position
    // ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

    // output to a specific pixel in the image
    // imageStore(img_output, coords, pixel);
}
